// Ocarina bot!
// www.nerdzoo.xyz

// Setting up variables for the Fourier Transorm 
#define FS 8000 //recording frequency 8000 Hz
#define samples 100 //record 100 samples
unsigned int sampling_period; 
long microseconds;
int V[samples]; //array to save microphone value samples
int t[samples]; //array to save time of each value
int Vsum = 0;
int DCBias = 0;
long Tstart = 0;
long Tend = 0;
int MaxNote = 0; //variable to save the main (loudest) frequency recorded 
int MaxVal = 0;  //strength of main frequency
float SNR = 5;   //signal to noise ratio threshold
int lastnote = 0; //variable to save the last main frequency for persistence 

// Notes
float F1 = 1050; //C 
float F2 = 1150; //D
float F3 = 1350; //F
float F4 = 1530; //G
float F5 = 1760; //A
float F6 = 1960; //B

// Motors
int motora[] = {6,4,9,11};  //mapping for L298n in a/b pins
int motorb[] = {5,3,10,12}; //mapping for L298n in a/b pins
int power[] = {7,2,8,13};   //mapping for L298n enable pins

//Directions
// 1 = motor fwd, 0 = stop, -1 = motor reverse
int rev[4] = {-1,-1,-1,-1};  //reverse
int fwd[4] = {1,1,1,1};      //forward
int rgt[4] = {1,-1,-1,1};    //right
int lft[4] = {-1,1,1,-1};    //left
int str[4] = {1,-1,1,-1};    //strafe right
int stl[4] = {-1,1,-1,1};    //strafe left
int stp[4] = {0,0,0,0};      //stop


void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  sampling_period = round(1.0 / FS * 1000000);  //figure out how may microseconds each sample needs to be at sampling frequency FS
}

void loop() {
  
  //Record samples:
  Tstart = 0;  //reset variable
  Vsum = 0;    //reset variable
  for (int i = 0; i < samples; i++)  //loops for number of samples
  {
    if (i == 0) Tstart = micros();   //grab the start time only at the beginning of the audio sample
    microseconds = micros() - Tstart; //grab the current time of each value relative to the start
    V[i] = analogRead(A0);    //measure microphone voltage
    t[i] = microseconds;      //record the time
    Vsum += V[i];  
    while (micros() < (microseconds + sampling_period)) {  //Wait to take the next sample according to the sampling frequency
    }  
  }

  DCBias = Vsum / samples;  //calculate the average voltage over the whole sample (DC offset)
  
  int NoteArray[6] = {      //run fourier transform to determine the strength of 6 test frequencies within the sample
    FTF(samples, V, DCBias, t, F1),
    FTF(samples, V, DCBias, t, F2),
    FTF(samples, V, DCBias, t, F3),
    FTF(samples, V, DCBias, t, F4),
    FTF(samples, V, DCBias, t, F5),
    FTF(samples, V, DCBias, t, F6)
  };

  int maxVal = 0;
  int maxNote = 0;
  int sumNote = 0;
  float avgNote = 0;

  //Test to see if 1 frequency > 2.5x the average of all the others
  for (int n = 0; n <= 5; n++) {
    if (NoteArray[n] > maxVal) {
      maxVal = NoteArray[n];
      maxNote = n;
    }
    sumNote += NoteArray[n];  
  }
  
  avgNote = (sumNote - maxVal) / 5;
  

  if (maxVal / avgNote > SNR) {
    if (maxNote==0) Move(motora, motorb, power, rev);    //Reverse
    if (maxNote==1) Move(motora, motorb, power, fwd);    //Forward
    if (maxNote==2) Move(motora, motorb, power, rgt);    //Turn Right
    if (maxNote==3) Move(motora, motorb, power, lft);    //Turn Left
    if (maxNote==4) Move(motora, motorb, power, str);    //Strafe Right
    if (maxNote==5) Move(motora, motorb, power, stl);    //Strafe Left
    if (maxNote == lastnote) SNR = ;
    else SNR = 6;
  }
  else {
    Move(motora, motorb, power, stp);
    SNR = 6;
  }
 
  lastnote = maxNote;
  
}

  //**********************
  //***CUSTOM FUNCTIONS***
  //**********************


float FTF(int num_samples, int sample_array[samples], int bias, int time_array[samples], float test_frequency) {
  /* Fourier Transform Function
   *  Inputs:
   *  num_samples: number of data samples
   *  sample_array: recorded analog mic data
   *  bias: DC Bias of mic data signal
   *  time_array: time data of mic signal in microseconds
   *  test_frequency: desired frequency to check for]
   */
  int Signal[num_samples];  
  float Wavelengths[num_samples];  //Array to store the number of test frequency periods that have passed for each mic sample.  Used to build test frequency square wave
  int TruncatedWavelengths[num_samples];  //Used to build test frequency square wave
  int Multiplier[num_samples];  //Test frequency square wave array
  int FTFArray[num_samples];    //Product of test frequency square wave and mic sample data
  long FTFSum[2];
  int FTFFit = 0;
  
  int test_period = 1000000/test_frequency;  // = 1 / test_frequency * 10e6

  for (int n = 0; n <= 1; n++) {  //Used for sin vs cosine multiplier array
    FTFSum[n] = 0;
    for (int j = 0; j < num_samples; j++) {
    Signal[j] = sample_array[j] - bias;  //Normalize sample array data about x axis
    //The following takes the mic sample array times and builds a square wave of the test frequency
    Wavelengths[j] = (time_array[j] - (0.25 * n * test_period)) / (0.5 * test_period);  //Look at how many multiples of half the test frequency period have passed
    TruncatedWavelengths[j] = int(Wavelengths[j]);  //Truncate float to int
    if ( (TruncatedWavelengths[j] % 2) == 0) Multiplier[j] = 1;  //If an even integer multiple of half test periods has passed, multiplier is 1
    else Multiplier[j] = -1;  //Odd integer multiples get -1
    FTFArray[j] = Signal[j] * Multiplier[j];  //Get product of test frequency square wave multiplier array
    FTFSum[n] += FTFArray[j];  // "integrate" FTF array to test correlation of sample signal and test frequency square wave
    }
  }
  FTFFit = abs(FTFSum[0]) + abs(FTFSum[1]);  //Sum two fourier transforms 90 degrees out of phase to account for phase shift
  return FTFFit;  //Returns correlation score of sample signal with test frequency
}

void Move(int in1[4], int in2[4], int enable[4], int command[4]) {
  for (int i = 0; i <= 3; i++) {
    digitalWrite2(in1[i], command[i]);
    digitalWrite2(in2[i], -1*command[i]);
    digitalWrite2(enable[i], command[i]*command[i]);
    Serial.print(command[i]);
    Serial.print(" ");
  }
}

void digitalWrite2(int pin, int value) {
  if (value == 1) digitalWrite(pin, HIGH);
  if (value == 0) digitalWrite(pin, LOW);
}




